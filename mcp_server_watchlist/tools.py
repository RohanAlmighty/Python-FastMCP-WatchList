
# Tool functions
import aiosqlite
from pydantic import BaseModel, Field
from mcp.server.fastmcp import Context
from mcp.types import SamplingMessage, TextContent
from mcp_server_watchlist.resources import get_all_movies

async def summarize_watchlist(ctx: Context) -> str:
	"""
	Summarize the user's watchlist using LLM sampling.
	The summary is generated by sending the list of movies to the LLM and asking for a friendly summary.
	"""
	movies = await get_all_movies()
	if not movies:
		return "Your watchlist is empty. Add some movies to get a summary!"
	movie_list = '\n'.join(movies)
	prompt = (
		"Here is a user's movie watchlist. "
		"Write a friendly summary or insight about their watchlist. "
		"You may mention genres, years, or trends if you notice any.\n\n"
		f"Watchlist:\n{movie_list}"
	)
	# Use LLM sampling
	try:
		message_result = await ctx.session.create_message(
			messages=[
				SamplingMessage(
					role="user",
					content=TextContent(type="text", text=prompt),
				)
			],
			system_prompt="You are a helpful movie assistant.",
			max_tokens=100,
		)

		if message_result.content.type == "text":
			return f"[Watchlist Summary]\n\n{message_result.content.text}"
		return f"[Watchlist Summary]\n\n{str(message_result.content)}"
		
	except Exception as e:
		return f"Failed to generate a summary: {str(e)}"

class RatingInput(BaseModel):
    """Schema for collecting rating input from user."""
    
    rating: float = Field(description="Rate the movie out of 10")

async def add_movie(title: str, year: int) -> str:
	"""
	Add a movie to the watchlist.
    
	Args:
		title: Movie name (exclude year)
		year: Year of release
	"""
	async with aiosqlite.connect("watchlist.db") as conn:
		await conn.execute("INSERT INTO watchlist (title, year) VALUES (?, ?)", (title, year))
		await conn.commit()
	# New movies have no rating by default
	return f"Added: Title: {title}, Year: {year}, Rating: N/A to watchlist."

async def mark_watched(title: str, ctx: Context) -> str:
	"""
	Mark a movie as watched.
    
	Args:
		title: Movie name (exclude year)
	Note:
		Pass only the movie name, not including the year. If the year is present, remove it before calling.
		Use elicitation to get rating from the user.
	"""
	async with aiosqlite.connect("watchlist.db") as conn:
		async with conn.execute("SELECT year FROM watchlist WHERE title = ?", (title,)) as cursor:
			row = await cursor.fetchone()
		if not row:
			return f"Movie not found in watchlist: Title: {title}"
		# Use elicitation to get rating input from user
		result = await ctx.elicit(
			message="Great! Please provide your rating.",
			schema=RatingInput,
		)
		rating = None
		if getattr(result, "action", None) == "accept" and getattr(result, "data", None):
			rating = result.data.rating
		await conn.execute("UPDATE watchlist SET watched = 1, rating = ? WHERE title = ?", (rating, title))
		await conn.commit()
		year = row[0]
		return f"Marked as watched: Title: {title}, Year: {year}, Rating: {rating if rating is not None else 'N/A'}"

async def unwatch_movie(title: str) -> str:
	"""
	Mark a movie as unwatched.
    
	Args:
		title: Movie name (exclude year)
	Note:
		Pass only the movie name, not including the year. If the year is present, remove it before calling.
	"""
	async with aiosqlite.connect("watchlist.db") as conn:
		async with conn.execute("SELECT year, rating FROM watchlist WHERE title = ?", (title,)) as cursor:
			row = await cursor.fetchone()
		if not row:
			return f"Movie not found in watchlist: Title: {title}"
		await conn.execute("UPDATE watchlist SET watched = 0, rating = NULL WHERE title = ?", (title,))
		await conn.commit()
		year = row[0]
		rating = row[1] if row[1] is not None else 'N/A'
		return f"Marked as unwatched: Title: {title}, Year: {year}, Rating: {rating}"

async def delete_movie(title: str) -> str:
	"""
	Delete a movie from the watchlist.
    
	Args:
		title: Movie name (exclude year)
	Note:
		Pass only the movie name, not including the year. If the year is present, remove it before calling.
	"""
	async with aiosqlite.connect("watchlist.db") as conn:
		async with conn.execute("SELECT year, rating FROM watchlist WHERE title = ?", (title,)) as cursor:
			row = await cursor.fetchone()
		if not row:
			return f"Movie not found in watchlist: Title: {title}"
		await conn.execute("DELETE FROM watchlist WHERE title = ?", (title,))
		await conn.commit()
		year = row[0]
		rating = row[1] if row[1] is not None else 'N/A'
		return f"Deleted: Title: {title}, Year: {year}, Rating: {rating} from watchlist."
